#include "nrf24_hal.h"
extern SPI_HandleTypeDef hspi1;
// Configure the GPIO lines of the nRF24L01 transceiver
// note: IRQ pin must be configured separately
void nRF24_GPIO_Init(void) {
    GPIO_InitTypeDef PORT = {0};

    // Enable the nRF24L01 GPIO and SPI peripherals
    RCC->APB2ENR |= nRF24_GPIO_PERIPHERALS; // e.g., RCC_APB2ENR_IOPAEN | RCC_APB2ENR_SPI1EN

    // Configure CSN pin (e.g., PA4)
    PORT.Pin = GPIO_PIN_4; // Update to your CSN pin
    PORT.Mode = GPIO_MODE_OUTPUT_PP;
    PORT.Pull = GPIO_NOPULL;
    PORT.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOA, &PORT);
    nRF24_CSN_H;

    // Configure CE pin (e.g., PA3)
    PORT.Pin = GPIO_PIN_3; // Update to your CE pin
    HAL_GPIO_Init(GPIOA, &PORT);
    nRF24_CE_L;

    // Configure SPI1 pins: SCK (PA5), MISO (PA6), MOSI (PA7)
    PORT.Pin = GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7;
    PORT.Mode = GPIO_MODE_AF_PP; // Use HAL macro for alternate function push-pull
    PORT.Pull = GPIO_NOPULL;
    PORT.Speed = GPIO_SPEED_FREQ_HIGH; // High speed for SPI
    HAL_GPIO_Init(GPIOA, &PORT);
}


// Low level SPI transmit/receive function (hardware dependent)
// input:
//   data - value to transmit via SPI
// return: value received from SPI
uint8_t nRF24_LL_RW(uint8_t data) {
    uint8_t rx_data;

    // Wait until TX buffer is empty
    while (HAL_SPI_GetState(&hspi1) != HAL_SPI_STATE_READY);

    // Transmit and receive one byte
    if (HAL_SPI_TransmitReceive(&hspi1, &data, &rx_data, 1, HAL_MAX_DELAY) != HAL_OK) {
        // Handle error (optional)
        Error_Handler();
    }

    return rx_data;
}
